/*
 * vISDN LAPD/q.931 protocol implementation
 *
 * Copyright (C) 2004-2005 Daniele Orlandi
 *
 * Authors: Daniele "Vihai" Orlandi <daniele@orlandi.com> 
 *
 * This program is free software and may be modified and distributed
 * under the terms and conditions of the GNU General Public License.
 *
 */

#include <linux/kernel.h>
#include <linux/tcp.h>

#include "lapd.h"
#include "lapd_in.h"
#include "lapd_out.h"
#include "tei_mgmt_nt.h"
#include "tei_mgmt_te.h"
#include "multiframe.h"

void lapd_frame_reject(
	struct sock *sk,
	struct sk_buff *rskb,
	enum lapd_format_errors error)
{
	struct lapd_opt *lo = lapd_sk(sk);


	switch (error == LAPD_FE_LENGTH) {
	case LAPD_FE_LENGTH:
		// MDL-ERROR-INDICATION(N)
		// w=1, x=1, y=0, z=0
	break;

	case LAPD_FE_N201:
		// MDL-ERROR-INDICATION(O)
		// 0, 0, 1, 0
	break;

	case LAPD_FE_UNDEFINED_COMMAND:
		// MDL-ERROR-INDICATION(L)
	break;

	case LAPD_FE_I_FIELD_NOT_PERMITTED:
		// MDL-ERROR-INDICATION(M)
	break;
	}

	if (lo->state == LAPD_DLS_LINK_CONNECTION_ESTABLISHED) {
		lo->retrans_cnt = 0;
		lapd_send_uframe(sk, LAPD_UFRAME_FUNC_SABME, 1, NULL, 0);
		lapd_start_t200(sk);

		if (!lo->in_timer_recovery)
			lapd_stop_t203(sk);

		lapd_change_state(sk, LAPD_DLS_AWAITING_REESTABLISH);
	}

/*

A FRMR-response shall not be generated by a data link layer entity;
however, on receipt of this frame actions according to subclause 5.8.6
of this ETS shall be taken.
**********************************************
	struct sk_buff *skb;
	skb = alloc_skb(
		sizeof(struct lapd_hdr) + sizeof(struct lapd_frmr),
		GFP_ATOMIC);
	if (!skb)
		return;

	if (lapd_prepare_uframe(sk, skb, LAPD_UFRAME_FUNC_FRMR, 0) < 0)
		return;

	struct lapd_frmr *frmr =
		(struct lapd_frmr *)skb_put(skb, sizeof(struct lapd_frmr));
	memset(frmr, 0x00, sizeof(struct lapd_frmr));

	struct lapd_hdr *rhdr = (struct lapd_hdr *)rskb->mac.raw;
	struct lapd_hdr_e *rhdr_e = (struct lapd_hdr_e *)rskb->mac.raw;

	switch (lapd_frame_type(rhdr->control)) {
	case LAPD_FRAME_TYPE_IFRAME:
	case LAPD_FRAME_TYPE_SFRAME:
		frmr->control = rhdr_e->control;
		frmr->control2 = rhdr_e->control2;

	case LAPD_FRAME_TYPE_UFRAME:
		frmr->control = 0x00;
		frmr->control2 = rhdr->control;
	break;
	};

	frmr->v_s = lo->v_s;
	frmr->c_r = lapd_rx_is_response(lo->nt_mode, rhdr->addr.c_r) ? 1 : 0;
	frmr->v_r = lo->v_r;

	frmr->z = z;
	frmr->y = y;
	frmr->x = x;
	frmr->w = w;

	lapd_send_completed_uframe(skb);
*/
}

static inline int lapd_socket_handle_uframe_ui(
	struct sock *sk,
	struct sk_buff *skb)
{
	lapd_debug_sk(sk, "received u-frame UI\n");

	skb->dev = NULL;
	skb_set_owner_r(skb, sk);

	int skb_len = skb->len;
	skb_queue_tail(&sk->sk_receive_queue, skb);

// Should we put this frame at the head, intead?
//	skb_queue_head(&sk->sk_receive_queue, skb);

	if (!sock_flag(sk, SOCK_DEAD))
		sk->sk_data_ready(sk, skb_len);

	return TRUE;
}

static inline int lapd_socket_handle_uframe_frmr(
	struct sock *sk,
	struct sk_buff *skb)
{
	lapd_debug_sk(sk, "received u-frame FRMR\n");

	struct lapd_opt *lo = lapd_sk(sk);
	struct lapd_frmr *frmr =
		(struct lapd_frmr *)(skb->mac.raw + sizeof(struct lapd_hdr));

	if ((frmr->control == 0 &&
	     lapd_uframe_function(frmr->control2) == LAPD_UFRAME_FUNC_UA) ||
	    (frmr->control != 0 &&
  	      (lapd_frame_type(frmr->control) == LAPD_FRAME_TYPE_IFRAME ||
	       lapd_frame_type(frmr->control) == LAPD_FRAME_TYPE_SFRAME))) {
		// MDL-ERROR-INDICATION(K)

		lo->retrans_cnt = 0;
		lapd_send_uframe(sk, LAPD_UFRAME_FUNC_SABME, 1, NULL, 0);

		if(lo->peer_busy || lo->in_timer_recovery) {
			lapd_start_t200(sk);
		} else {
			lapd_stop_t200(sk);
			lapd_start_t203(sk);
		}

		lapd_change_state(sk, LAPD_DLS_AWAITING_REESTABLISH);
	}

	return FALSE;
}

static inline int lapd_socket_handle_uframe_xid(
	struct sock *sk,
	struct sk_buff *skb)
{
	lapd_debug_sk(sk, "received u-frame XID\n");

	// Should we reject it?

	return FALSE;
}

static inline int lapd_socket_handle_uframe(
	struct sock *sk,
	struct sk_buff *skb)
{
	struct lapd_hdr *hdr = (struct lapd_hdr *)skb->mac.raw;

	lapd_debug_sk(sk, "received u-frame\n");

	if (lapd_uframe_function(hdr->control) != LAPD_UFRAME_FUNC_UI &&
	    skb->len != 3) {
		lapd_debug_sk(sk,
			"received u-frame with wrong size (%d), rejecting\n",
			skb->len);

		lapd_frame_reject(sk, skb, LAPD_FE_LENGTH);

		return FALSE;
	}

	int queued = FALSE;
	switch (lapd_uframe_function(hdr->control)) {
	case LAPD_UFRAME_FUNC_SABME:
		queued = lapd_socket_handle_uframe_sabme(sk, skb);
	break;

	case LAPD_UFRAME_FUNC_DM:
		queued = lapd_socket_handle_uframe_dm(sk, skb);
	break;

	case LAPD_UFRAME_FUNC_UI:
		queued = lapd_socket_handle_uframe_ui(sk, skb);
	break;

	case LAPD_UFRAME_FUNC_DISC:
		queued = lapd_socket_handle_uframe_disc(sk, skb);
	break;

	case LAPD_UFRAME_FUNC_UA:
		queued = lapd_socket_handle_uframe_ua(sk, skb);
	break;

	case LAPD_UFRAME_FUNC_FRMR:
		queued = lapd_socket_handle_uframe_frmr(sk, skb);
	break;

	case LAPD_UFRAME_FUNC_XID:
		queued = lapd_socket_handle_uframe_xid(sk, skb);
	break;

	case LAPD_UFRAME_FUNC_INVALID:
		lapd_printk_sk(KERN_ERR, sk,
			"received invalid u-frame function %d,"
			" rejecting frame\n",
			hdr->control);

		lapd_frame_reject(sk, skb, LAPD_FE_UNDEFINED_COMMAND);
		queued = FALSE;
	}

	return queued;
}

void lapd_deliver_internal_message(
	struct sock *sk,
	enum lapd_int_msg_type type,
	int param)
{
	if (type == LAPD_INT_MDL_ASSIGN_REQUEST)
		lapd_mdl_assign_request(sk, param);
	else if (type == LAPD_INT_MDL_ERROR_RESPONSE)
		lapd_mdl_error_response(sk);
	else if (type == LAPD_INT_MDL_REMOVE_REQUEST)
		lapd_mdl_remove_request(sk);
	else
		BUG();
}

int lapd_process_frame(
	struct sock *sk,
	struct sk_buff *skb)
{
	int queued = 0;

	if (!skb->dev) {
		struct lapd_internal_msg *msg =
			(struct lapd_internal_msg *)skb->data;

		lapd_deliver_internal_message(sk, msg->type, msg->param);

		return TRUE;
	}

	struct lapd_hdr *hdr = (struct lapd_hdr *)skb->mac.raw;
	switch (lapd_frame_type(hdr->control)) {
	case LAPD_FRAME_TYPE_IFRAME:
		queued = lapd_socket_handle_iframe(sk, skb);
	break;

	case LAPD_FRAME_TYPE_SFRAME:
		queued = lapd_socket_handle_sframe(sk, skb);
	break;

	case LAPD_FRAME_TYPE_UFRAME:
		queued = lapd_socket_handle_uframe(sk, skb);
	break;
	};

	return queued;
}

/*****************+
 * WARNING: this function may be called under lapd_hash_lock and acquires
 * bh_lock_sock. To avoid deadlocks, nothing inside this functions should
 * acquire lapd_hash_lock again
 *
 */

int lapd_backlog_rcv(
	struct sock *sk,
	struct sk_buff *skb)
{
	if (!lapd_process_frame(sk, skb))
		kfree_skb(skb);

	return 0;
}

static int lapd_pass_frame_to_socket(
	struct sock *sk,
	struct sk_buff *skb)
{
	int queued;

	// Ensure serialization within a socket
	bh_lock_sock(sk);

	if (!sock_owned_by_user(sk)) {
		queued = lapd_process_frame(sk, skb);
	} else {
		sk_add_backlog(sk, skb);
		queued = 1;
	}

	bh_unlock_sock(sk);

	return queued;
}

static inline void lapd_socketless_reply_dm(struct sk_buff *skb)
{
	struct sk_buff *rskb;
	rskb = alloc_skb(sizeof(struct lapd_hdr_e), GFP_ATOMIC);
	if (!rskb)
		return;

	rskb->dev = skb->dev;
	rskb->protocol = __constant_htons(ETH_P_LAPD);
	rskb->h.raw = rskb->nh.raw = rskb->mac.raw = rskb->data;

	struct lapd_hdr *rhdr =
		(struct lapd_hdr *)skb_put(rskb,
					sizeof(struct lapd_hdr));

	struct lapd_hdr *hdr = (struct lapd_hdr *)skb->mac.raw;

	rhdr->addr.sapi = hdr->addr.sapi;
	rhdr->addr.c_r = skb->dev->flags & IFF_ALLMULTI ? 0 : 1;
	rhdr->addr.ea1 = 0;
	rhdr->addr.ea2 = 1;
	rhdr->addr.tei = hdr->addr.tei;
	rhdr->control = lapd_uframe_make_control(
				LAPD_UFRAME_FUNC_DM,
				hdr->u.p_f);

	lapd_send_frame(rskb);
}

/*
 * When we are the network and we cannot associate or create a socket for the
 * incoming frame, we at least reply with a DM. This is expecially useful when
 * the application crashes and the TEs try to re-establsh multiple-frame mode.
 */

static inline void lapd_handle_socketless_frame(struct sk_buff *skb)
{
	struct lapd_hdr *hdr = (struct lapd_hdr *)skb->mac.raw;

	if (lapd_frame_type(hdr->control) == LAPD_FRAME_TYPE_UFRAME &&
	    (lapd_uframe_function(hdr->control) == LAPD_UFRAME_FUNC_SABME ||
	     lapd_uframe_function(hdr->control) == LAPD_UFRAME_FUNC_DISC)) {
		lapd_socketless_reply_dm(skb);
	}
}

/*************************
 * lapd_pass_frame_to_socket_nt() handles an incoming frame, searches
 * the appropriate socket and creates a new socket if not found.
 *
 * Frames are serialized when relative to the same socket
 */

static inline int lapd_pass_frame_to_socket_nt(
	struct sk_buff *skb)
{
	struct sock *listening_sk = NULL;
	struct sock *sk = NULL;
	struct hlist_node *node;
	struct lapd_hdr *hdr = (struct lapd_hdr *)skb->mac.raw;
	int queued = 0;

	write_lock_bh(&lapd_hash_lock);
	sk_for_each(sk, node, lapd_get_hash(skb->dev)) {
		struct lapd_opt *lo = lapd_sk(sk);

		if (lo->dev == skb->dev) {

			if (sk->sk_state == TCP_LISTEN) {
				listening_sk = sk;
				continue;
			}

			if (lo->sapi == hdr->addr.sapi &&
		 	    lo->tei == hdr->addr.tei) {

				skb->sk = sk;

				write_unlock_bh(&lapd_hash_lock);

				queued = lapd_pass_frame_to_socket(sk, skb);

				goto frame_handled;
			}
		}
	}

	if (listening_sk) {
		// A socket has not been found
		struct lapd_hdr *hdr = (struct lapd_hdr *)skb->mac.raw;
		
		if (hdr->addr.sapi != LAPD_SAPI_Q931 &&
		    hdr->addr.sapi != LAPD_SAPI_X25) {
			lapd_printk(KERN_WARNING,
				"SAPI %d not supported\n",
				hdr->addr.sapi);
		}

		struct sock *newsk;
		newsk = lapd_new_sock(listening_sk, hdr->addr.tei,
			hdr->addr.sapi);

		if (!newsk) {
			write_unlock_bh(&lapd_hash_lock);
			return FALSE;
		}

		sk_add_node(newsk, lapd_get_hash(skb->dev));
		write_unlock_bh(&lapd_hash_lock);

		skb->sk = newsk;

		struct lapd_new_dlc *new_dlc;
		new_dlc = kmalloc(sizeof(struct lapd_new_dlc), GFP_ATOMIC);
		if (!new_dlc)
			return FALSE;

		new_dlc->sk = newsk;
		// sock_hold(new_dlc->sk);

		struct lapd_opt *listening_lo = lapd_sk(listening_sk);
		hlist_add_head(&new_dlc->node, &listening_lo->new_dlcs);

		queued = lapd_pass_frame_to_socket(newsk, skb);

		if (!sock_flag(listening_sk, SOCK_DEAD))
			listening_sk->sk_data_ready(listening_sk, skb->len);

		// sock_put(newsk);
	} else {
		lapd_handle_socketless_frame(skb);

		write_unlock_bh(&lapd_hash_lock);
	}

frame_handled:

	return queued;
}

/*************************
 * lapd_pass_frame_to_socket_te() handles an incoming frame, searches
 * the appropriate socket and handles the frame.
 *
 * Frames are serialized when relative to the same socket
 *
 * Locking problem: When receiving a broadcast we have to keep
 * a read-lock on lapd_hash and pass the frame to each single
 * socket handler. Unfortunately, the socket handler may call
 * sk_del_node_init(), so, it needs a write lock on lapd_hash.
 *
 * Solution 1: Easy but ugly... acquire a write lock and keep
 *             it for the whole processing. Low concurrency,
 *             potential deadlocks. The write lock should be
 *             kept when not needed too...
 *
 * Solution 2: Move sk_del_node_init() away and only acquire
 *             needed locks.
 *
 * Solution 3: Use RCU for sockets hash? (Hard as sockets doesn't have
 *             RCU structure)
 */


static inline int lapd_pass_frame_to_socket_te(
	struct sk_buff *skb)
{

	struct sock *sk;
	struct hlist_node *node, *tmp;
	struct lapd_hdr *hdr = (struct lapd_hdr *)skb->mac.raw;
	int queued = 0;

	read_lock_bh(&lapd_hash_lock);
	if (hdr->addr.tei != LAPD_BROADCAST_TEI) {
		sk_for_each(sk, node, lapd_get_hash(skb->dev)) {
			struct lapd_opt *lo = lapd_sk(sk);

			if (lo->dev == skb->dev &&
			    lo->sapi == hdr->addr.sapi &&
			    lo->usr_tme->tei == hdr->addr.tei) {

				skb->sk = sk;

				queued = lapd_pass_frame_to_socket(sk, skb);

				break;
			}
		}
	} else {
		sk_for_each_safe(sk, node, tmp, lapd_get_hash(skb->dev)) {
			struct lapd_opt *lo = lapd_sk(sk);

			if (lo->dev == skb->dev &&
			    lo->sapi == hdr->addr.sapi) {
				if (skb->list)
					skb = skb_clone(skb, GFP_ATOMIC);

				skb->sk = sk;

				queued = lapd_pass_frame_to_socket(sk, skb);
			}
		}
	}
	read_unlock_bh(&lapd_hash_lock);

	return queued;
}

int lapd_rcv(
	struct sk_buff *skb,
	struct net_device *dev,
	struct packet_type *pt)
{
	// Ignore frames not destined to us
	if (skb->pkt_type != PACKET_HOST)
		goto not_ours;

	// Don't mangle buffer if shared
	if (!(skb = skb_share_check(skb, GFP_ATOMIC)))
		goto err_share_check;

	// Minimum frame is header + 2 CRC <- not sent yet by driver
	if (skb->len < sizeof(struct lapd_hdr)) // + 2)
		goto err_small_frame;

	// Size check and make sure header is contiguous
	if (!pskb_may_pull(skb, sizeof(struct lapd_hdr)))
		goto err_pskb_may_pull;

	BUG_ON(!skb->dev);

	skb->h.raw = skb->nh.raw = skb->mac.raw = skb->data;

	struct lapd_hdr *hdr = (struct lapd_hdr *)skb->mac.raw;
	if (hdr->addr.ea1 || !hdr->addr.ea2) {
		lapd_printk_dev(KERN_WARNING, skb->dev,
			"improper ea bits in received frame\n");
		goto err_improper_ea;
	}

	int queued = 0;
	if (skb->dev->flags & IFF_ALLMULTI) {
		if (hdr->addr.sapi == LAPD_SAPI_TEI_MGMT)
			lapd_ntme_handle_frame(skb);
		else
			queued = lapd_pass_frame_to_socket_nt(skb);
	} else {
		if (hdr->addr.sapi == LAPD_SAPI_TEI_MGMT)
			lapd_utme_handle_frame(skb);
		else
			queued = lapd_pass_frame_to_socket_te(skb);

	}

	if (!queued)
		kfree_skb(skb);

	return 0;

err_small_frame:
err_improper_ea:
err_pskb_may_pull:
err_share_check:
	kfree_skb(skb);
not_ours:

	return 0;
}

