
HISTORY:


9/8/2005 23:40
In production on nabla

18/2/2005 2:05
First call made throught the public network... no voice however :)

22/2/2005 01:23
First PPP connecion

18/3/2005 14:30
LAPD with full features

17/4/2005 21:00
q.931 completed

20/4/2005 01:00
First audio heared

26/4/2004 22:40
First half-call (voice in only one direction :))

26/4/2004 23:20
First full-call :)



DL-UNIT DATA-REQUEST
sendmsg(2) with MSG_OOB flag

DL-UNIT DATA-INDICATION
recvmsg(2) with MSG_OOB flag

DL-DATA-REQUEST
sendmsg(2)

DL-DATA-INDICATION
recvmsg(2)

DL-ESTABLISH-REQUEST
connect(2)

DL-ESTABLISH-INDICATION
Error from recvmsg
EISCONN

DL-ESTABLISH-CONFIRM
Successful return from connect(2) in synchronous operation

DL-RELEASE-REQUEST
shutdown(2)

DL-RELEASE-INDICATION
Error from connect(2)
EIO = Too many retries assigning TEI
ETIMEDOUT = Too many retries establishing connection
Error from recvmsg
ECONNRESET 

DL-RELEASE-CONFIRM
Successful return from shutdown(2) in synchronous operation

Tei Management:
-----------------------------------------------
MDL-ASSIGN-REQUEST
lapd_mdl_assign_request

MDL-ASSIGN-INDICATION
lapd_utme_start_tei_request

MDL-REMOVE-REQUEST
lapd_mdl_remove_request

MDL-ERROR-INDICATION

MDL-ERROR-RESPONSE
lapd_mdl_error_response

Physical
-----------------------------------------------
PH-DATA-REQUEST
dev_queue_xmit

PH-DATA-INDICATION
lapd_rcv

PH-ACTIVATE-REQUEST
PH-ACTIVATE-INDICATION
netif_carrier_on

PH-DEACTIVATE-REQUEST
PH-DEACTIVATE-INDICATION
netif_carrier_off -> lapd_device_event/state & 

MPH-ACTIVATE-INDICATION
MPH-DEACTIVATE-REQUEST
MPH-DEACTIVATE-INDICATION
MPH-INFORMATION-INDICATION



q.931 procedures:
-------------------------------

L3		

DL-ESTABLISH-REQUEST

		MDL-ASSIGN-REQUEST
				PH-ACTIVATE-REQ
				wait
				PH-ACTIVATE-IND
		wait
		MDL-ASSIGN-INDICATION
wait
DL-ESTABLISH-CONFIRM




Locking critical functions:
lapd_utme_T202_timer
	Acquires:
	spin_lock(&tme->lock);
	read_lock_bh(&lapd_hash_lock);
	bh_sock_lock(sk);

lapd_utme_start_tei_request
	Acquires:
	spin_lock(&tme->lock);
	


lapd_utme_recv_tei_remove
	Acquires:
	read_lock_bh(&lapd_utme_hash_lock);
	read_lock_bh(&lapd_hash_lock);
	bh_sock_lock(sk);

lapd_pass_frame_to_socket_te
	Acquires:
	read_lock_bh(&lapd_hash_lock);
	bh_lock_sock(sk); (in lapd_pass_frame_to_socket())


Sep  1 17:59:39 bastard kernel: ip            D 00000000     0  7037   6765                     (NOTLB)
Sep  1 17:59:39 bastard kernel: da753e18 00000082 ddb88040 00000000 00000000 00000000 4611a340 000f4214 
Sep  1 17:59:39 bastard kernel:        c03b58c8 dd972060 dd9721b4 c033f9e0 dd972060 00000246 c033f9e8 c02d050e 
Sep  1 17:59:39 bastard kernel:        00000001 dd972060 c01171a0 c033f9e8 c033f9e8 ffffff66 00000246 c03b620a 
Sep  1 17:59:39 bastard kernel: Call Trace:
Sep  1 17:59:39 bastard kernel:  [<c02d050e>] __down+0x6e/0xd0
Sep  1 17:59:39 bastard kernel:  [<c01171a0>] default_wake_function+0x0/0x10
Sep  1 17:59:39 bastard kernel:  [<c02d0673>] __down_failed+0x7/0xc
Sep  1 17:59:39 bastard kernel:  [<c0270117>] .text.lock.rtnetlink+0xb/0x54
Sep  1 17:59:39 bastard kernel:  [<c026a868>] unregister_netdev+0x8/0x15
Sep  1 17:59:39 bastard kernel:  [<e1415181>] vnd_chan_disconnect+0x41/0x50 [visdn_netdev]
Sep  1 17:59:39 bastard kernel:  [<e141d83c>] visdn_disconnect+0xdc/0x120 [visdn_core]
Sep  1 17:59:39 bastard kernel:  [<e141d4b7>] visdn_negotiate_parameters+0x1b7/0x1c0 [visdn_core]
Sep  1 17:59:39 bastard kernel:  [<e14431bd>] hfc_chan_open+0xbd/0x580 [hfc_4s]
Sep  1 17:59:39 bastard kernel:  [<e14152c9>] vnd_netdev_open+0x69/0x70 [visdn_netdev]
Sep  1 17:59:39 bastard kernel:  [<c02683f8>] dev_open+0x58/0x70
Sep  1 17:59:39 bastard kernel:  [<c026982c>] dev_change_flags+0x4c/0x110
Sep  1 17:59:39 bastard kernel:  [<c02a620e>] devinet_ioctl+0x4ae/0x550
Sep  1 17:59:39 bastard kernel:  [<c02a7d96>] inet_ioctl+0x66/0x90
Sep  1 17:59:39 bastard kernel:  [<c02604d0>] sock_ioctl+0x160/0x210
Sep  1 17:59:39 bastard kernel:  [<c0260370>] sock_ioctl+0x0/0x210
Sep  1 17:59:39 bastard kernel:  [<c01611b6>] do_ioctl+0x46/0x60
Sep  1 17:59:39 bastard kernel:  [<c0161345>] vfs_ioctl+0x55/0x1c0
Sep  1 17:59:39 bastard kernel:  [<c01614f0>] sys_ioctl+0x40/0x70
Sep  1 17:59:39 bastard kernel:  [<c0102c49>] sysenter_past_esp+0x52/0x79







Some ideas for me...

[00:50] <fsck> - una breve introduzione a come caricare i moduli, attivare le interfacce
[00:50] <fsck> - una breve intro a chan_visdn
[00:50] <fsck> - la faccenda del crash (che da una cattiva impressione, visto che al primo colpo uno dimentica qualcosa :)
[00:51] <fsck> - un buildscript anche molto rozzo, che faccia aclocal/automake/autoconf e i make necessari


[01:18] <fsck> uhm l'ecocancel?
[01:19] <vihai> E' da configurare per ogni interfaccia? In che casi non va messo?
[01:20] <fsck> quando quell'interfaccia non è al margine di una rete tutta digitale è inutile
[01:20] <fsck> la segnalazione
[01:20] <fsck> o meglio la "variante" della segnalazione
[01:21] <vihai> Non faccio prima a vedere se il canale connesso è digiale o meno e abilitare l'echo cancel dinamicamente?
[01:21] <fsck> come fai a sapere se il canale a valle è digitale o meno?
[01:21] <fsck> e soprattutto se lui fa l'ecocancel
[01:22] <vihai> C'è un flag in *, devo vedere se è fatto apposta
[01:23] <fsck> quello della digital quality?
[01:23] <fsck> se è quello è per settare l'ec PER CALL
[01:23] <vihai> Comunqu posso fare un (yes, no, auto) 
[01:23] <vihai> AST_FLAG_DIGITAL
[01:23] <fsck> si è quello
[01:23] <fsck> le chiamate fax non vogliono l'ec
[01:24] <fsck> io metterei un flag



[14:19] <vihai> Allora... ragiono a voce alta... tu fai segno con la testa se va bene
[14:19] <vihai> Io ricevo un setup_indication dalla libq931 (ovvero ho ricevuto un SETUP)
[14:20] <vihai> Nel setup_indication c'è un numero valido, overlap dialing è disattivato, io lancio il pbx e finisco mandando un proceeding
[14:20] <vihai> Se il numero non è completo/invalito, rispondo con un setup_reject
[14:21] <fsck> ok
[14:22] <vihai> Se l'overlap è abilitato guardo se il numero PUO' matchare
[14:22] <vihai> Se non puo' matchare => reject
[14:22] <vihai> Finché può matchare continuo l'overlap
[14:22] <vihai> Quando il numero matcha un'estensione (che può essere una regexp) devo guardare se l'estensione supporta l'overlap
[14:23] <vihai> Se lo supporta faccio partire il pbx e mando il resto delle cifre come frame DTMF
[14:24] <vihai> Se non lo supporta uso un timeout
[14:24] <vihai> Il problema è... come capisco se l'estensione supporta l'overlap dialing?
[14:26] <fsck> mhh... non credo ci sia un modo adesso
[14:29] <vihai> Uhm... allora....
[14:30] <vihai> Posso fare che se durante l'overlap esiste un'estensione e NON può matchare ulteriormente (ovvero non è una regexp) faccio partire subito il pbx
