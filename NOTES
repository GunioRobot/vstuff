

How to write a vISDN driver:

The ISDN is a complex environment. On the same physical interface there are
several multiplexed channels, from three channels on basic rate interfaces
up to 30 channels on primary rate interfaces.

The role of a vISDN driver is analougue to that of a network driver but with
much more architectural complexity.

The increased complexity begins with the need to handle multiple channels,
each one with its role, bitrate, framing and type of payload. For example,
a bearer (B) channel is a full-duplex, fixed bitrate, synchronous and
point-to-point bitstream, however, it may transport streamed voice, video,
packets, asynchronous data, etc... and the far-end point will be connected
by means of a complex signalling protocol.

Luckilly your driver will not be involved with much of that complexity,
however, since most hardware provides helpers for handling some type of
payload, your driver may want to make use of them.


- Initialize the port(s)
- Register the port(s)

- For each channel
  - Initialize
  - Register

Your driver will export a series of callbacks:

connect()
disconnect()
open()
close()

Before a channel il your driver is going to be used it must be connected.
When the connection command comes from the user, vISDN core will invoke the
visdn_cxc_connect() function for the crossconnector. The CXC in turn will
invoke the connect() callback so that you can do the real stuff.

In the connect() function you may allocate the resources on the hardware.

When the entity responsible for the channel management decides it is time
to start moving stuff on the channel, it will call open() and your driver
may thus configure the hardware for the actual transfer.

No transfer request will be sent to the driver and no request should be made
by the driver before open() returns successfully.

Nothing forces you to allocate the resources in connect(), you may do all
the work in open(). On the other side, you may find out that certain
constraints become known just after you allocate the resources on the hardware.
For example, on HFC-4S/8S/E1 based boards the MTU depends on the FIFO size but
the FIFO may not be all of the same size, so, you only know the actual
MTU after the FIFO has been allocated.
By allocating the hardware resource in the connect() phase you have a chance of
re-negotiating the parameters before the channel is actually opened (which
may be too late).

Negotiation
-----------

When connecting two channels together, absolutely no sort of payload adaptation
is performed by the crossconnector. The crossconnector's duty is to move the
channel's payload from one channel to another as fast as it can.

The consequence is that the channels must agree on what the payload is, how
it is formatted, how it should be moved and so on. Therefore, the
crossconnector arbitrates a negotiation of such parameters between the channels
until an agreement can be found.

To date, the following parameters have been identified:

- Layer 1 protocol
- Bitrate
- Bit-order

Furthermore, when the Layer 1 protocol is a framed protocol, we need to know
the maximum frame size supported by the channels and (more importantly) the
maximum frame size along the path in either direction.

It is important to understand that each channel is full-duplex, thus, it is
actually comprised of two simplex channels. Parameters negotiation could
have been performed on each simplex channel independently, however, some
hardware does not support etherogeneous channel configuration which, in turn,
is often unneeded. So, i

start_queue, stop_queue, wake_queue
These callbacks may be called with interrupts disabled, must not sleep and
must not call each other.
See Documentation/networking/netdevices.txt for a template

HISTORY:


9/8/2005 23:40
In production on nabla

18/2/2005 2:05
First call made throught the public network... no voice however :)

22/2/2005 01:23
First PPP connecion

18/3/2005 14:30
LAPD with full features

17/4/2005 21:00
q.931 completed

20/4/2005 01:00
First audio heared

26/4/2004 22:40
First half-call (voice in only one direction :))

26/4/2004 23:20
First full-call :)



DL-UNIT DATA-REQUEST
sendmsg(2) with MSG_OOB flag

DL-UNIT DATA-INDICATION
recvmsg(2) with MSG_OOB flag

DL-DATA-REQUEST
sendmsg(2)

DL-DATA-INDICATION
recvmsg(2)

DL-ESTABLISH-REQUEST
connect(2)

DL-ESTABLISH-INDICATION
Error from recvmsg
EISCONN

DL-ESTABLISH-CONFIRM
Successful return from connect(2) in synchronous operation

DL-RELEASE-REQUEST
shutdown(2)

DL-RELEASE-INDICATION
Error from connect(2)
EIO = Too many retries assigning TEI
ETIMEDOUT = Too many retries establishing connection
Error from recvmsg
ECONNRESET 

DL-RELEASE-CONFIRM
Successful return from shutdown(2) in synchronous operation

Tei Management:
-----------------------------------------------
MDL-ASSIGN-REQUEST
lapd_mdl_assign_request

MDL-ASSIGN-INDICATION
lapd_utme_start_tei_request

MDL-REMOVE-REQUEST
lapd_mdl_remove_request

MDL-ERROR-INDICATION

MDL-ERROR-RESPONSE
lapd_mdl_error_response

Physical
-----------------------------------------------
PH-DATA-REQUEST
dev_queue_xmit

PH-DATA-INDICATION
lapd_rcv

PH-ACTIVATE-REQUEST
PH-ACTIVATE-INDICATION
netif_carrier_on

PH-DEACTIVATE-REQUEST
PH-DEACTIVATE-INDICATION
netif_carrier_off -> lapd_device_event/state & 

MPH-ACTIVATE-INDICATION
MPH-DEACTIVATE-REQUEST
MPH-DEACTIVATE-INDICATION
MPH-INFORMATION-INDICATION



q.931 procedures:
-------------------------------

L3		

DL-ESTABLISH-REQUEST

		MDL-ASSIGN-REQUEST
				PH-ACTIVATE-REQ
				wait
				PH-ACTIVATE-IND
		wait
		MDL-ASSIGN-INDICATION
wait
DL-ESTABLISH-CONFIRM




Locking critical functions:
lapd_utme_T202_timer
	Acquires:
	spin_lock(&tme->lock);
	read_lock_bh(&lapd_hash_lock);
	bh_sock_lock(sk);

lapd_utme_start_tei_request
	Acquires:
	spin_lock(&tme->lock);
	


lapd_utme_recv_tei_remove
	Acquires:
	read_lock_bh(&lapd_utme_hash_lock);
	read_lock_bh(&lapd_hash_lock);
	bh_sock_lock(sk);

lapd_pass_frame_to_socket_te
	Acquires:
	read_lock_bh(&lapd_hash_lock);
	bh_lock_sock(sk); (in lapd_pass_frame_to_socket())








Some ideas for me...

[01:18] <fsck> uhm l'ecocancel?
[01:19] <vihai> E' da configurare per ogni interfaccia? In che casi non va messo?
[01:20] <fsck> quando quell'interfaccia non è al margine di una rete tutta digitale è inutile
[01:20] <fsck> la segnalazione
[01:20] <fsck> o meglio la "variante" della segnalazione
[01:21] <vihai> Non faccio prima a vedere se il canale connesso è digiale o meno e abilitare l'echo cancel dinamicamente?
[01:21] <fsck> come fai a sapere se il canale a valle è digitale o meno?
[01:21] <fsck> e soprattutto se lui fa l'ecocancel
[01:22] <vihai> C'è un flag in *, devo vedere se è fatto apposta
[01:23] <fsck> quello della digital quality?
[01:23] <fsck> se è quello è per settare l'ec PER CALL
[01:23] <vihai> Comunqu posso fare un (yes, no, auto) 
[01:23] <vihai> AST_FLAG_DIGITAL
[01:23] <fsck> si è quello
[01:23] <fsck> le chiamate fax non vogliono l'ec
[01:24] <fsck> io metterei un flag



[14:19] <vihai> Allora... ragiono a voce alta... tu fai segno con la testa se va bene
[14:19] <vihai> Io ricevo un setup_indication dalla libq931 (ovvero ho ricevuto un SETUP)
[14:20] <vihai> Nel setup_indication c'è un numero valido, overlap dialing è disattivato, io lancio il pbx e finisco mandando un proceeding
[14:20] <vihai> Se il numero non è completo/invalito, rispondo con un setup_reject
[14:21] <fsck> ok
[14:22] <vihai> Se l'overlap è abilitato guardo se il numero PUO' matchare
[14:22] <vihai> Se non puo' matchare => reject
[14:22] <vihai> Finché può matchare continuo l'overlap
[14:22] <vihai> Quando il numero matcha un'estensione (che può essere una regexp) devo guardare se l'estensione supporta l'overlap
[14:23] <vihai> Se lo supporta faccio partire il pbx e mando il resto delle cifre come frame DTMF
[14:24] <vihai> Se non lo supporta uso un timeout
[14:24] <vihai> Il problema è... come capisco se l'estensione supporta l'overlap dialing?
[14:26] <fsck> mhh... non credo ci sia un modo adesso
[14:29] <vihai> Uhm... allora....
[14:30] <vihai> Posso fare che se durante l'overlap esiste un'estensione e NON può matchare ulteriormente (ovvero non è una regexp) faccio partire subito il pbx



This is an attempt at writing a new and improved ISDN layer for Linux

Fundamently it is composed of three steps:

- Implement q.921/LAPD thorught the netdev infrastructure
- Implement some reference driver
- Implement a TDM bus and voice API

- Manages one TEI per socket meaning that more than one Layer 3 client may speak
  indipendendently on the channel, e.g. a low level q.931 signalling adaptor for
  voice applications, an high-level q.931 daemon and an X.25 endpoint daemon (?).

The ISDN networking doesn't properly map with the socket layer or with the
ISO/OSI layers.

The Layer 1 (Physical layer) can (and will) be activated/deactivated on BRI ports
when Layer 2 is idle for a specified timeout

There is no MAC address and network address, 

Un DLC è identificato da:

(Interfaccia, TEI, SAPI)


There are two roles, the NT and the TE
Data flows from a TE to the NT and from the NT to one or more TEs.
Broadcasts are supported in one direction only (from NT to TE).

Avrei potuto implementare anche il q.921 in user mode

Una socket è un'entità che rappresenta l'endpoint di una comunicazione.

Solo una socket può essere aperta con ruolo di NT mentre più di una socket può
essere aperta in TE mode


La trasmissione unacknowledged (simile a SOCK_DGRAM) e acknowledged
(analoga a SOCK_SEQPACKET) sono MODALITA' di trasmissione all'interno della stessa
Data Link Connection, quindi ho deciso di implementarle all'interno della stessa
socket.


VGSM
---------------------------------------

Initialization:

AT<cr>
Wait OK
(if not, wait 200ms and retry)

AT+IPR=38400

Extended error codes:
AT+CMEE=1

AT+CPIN

AT+CPIN=****

+++ IMPOSTARE OROLOGIO
